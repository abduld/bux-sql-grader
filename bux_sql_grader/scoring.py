import logging

import numpy

log = logging.getLogger(__name__)


class MySQLScorer(object):
    """ Generates a score between 0 and 1 for a MySQL query problem.

    :param str student_answer: the student query
    :param tuple student_results: a two item tuple: (result columns,
                                  result rows)
    :param str grader_answer: the student query
    :param tuple grader_results: a two item tuple: (result columns,
                                  result rows)
    :param dict score_map: an optional scoring map which will override DEFAULT_SCORE_MAP
    :returns: a two item tuple with score (float), message (str)
    :rtype: tuple

    This class defines several test methods that score various aspects of the
    query results.

    The ``DEFAULT_SCORE_MAP`` defines a dict mapping scoring method to
    weight.

    Cummulative score is determined by running each test method and averaging
    the resulting scores along with their respective weights.

    """

    #: Maps scoring methods to weight contributed to overall score
    #: Can be overriden by passing an alternate ``score_map``
    DEFAULT_SCORE_MAP = {
        'rows_match': 1,
        'keywords_match': 0.25,
    }

    def __init__(self, student_answer, student_results, grader_answer,
                 grader_results, score_map=None):
        self.student_answer = student_answer
        self.student_results = student_results
        self.grader_answer = grader_answer
        self.grader_results = grader_results

        self.score_map = self.DEFAULT_SCORE_MAP
        if score_map:
            if not isinstance(score_map, dict):
                raise ValueError

            # Merge scoring map with defaults
            self.score_map = dict(self.score_map.items() + score_map.items())

    def score(self):
        """ Generates a score by running through all methods in the scoring map """
        scores = []
        weights = []
        messages = []

        # Generate scores
        for func, weight in self.score_map.iteritems():
            if not hasattr(self, func):
                log.error("Illegal scoring func: %s", func)
                continue

            score_func = getattr(self, func)
            score, msg = score_func()

            # Build a list of scores and weights
            # TODO: Use a tuple
            scores.append(score)
            weights.append(weight)

            # Track any messages generated by the scoring method
            if msg:
                messages.append(msg)

        # Calculate score based on weights
        score = numpy.average(scores, weights=weights)

        # Convert to built-in float
        score = numpy.asscalar(score)

        return score, messages

    def rows_match(self):
        """ Perscribes points for matching rows """
        score = 0
        msg = ''
        if self.student_results[1] == self.grader_results[1]:
            score = 1

        # Add unsorted row comparison logic here to provide partial credit

        return score, msg

    def keywords_match(self):
        """ Perscibes points for keyword matches """
        KEYWORDS = ['WHERE', 'ORDER BY', 'LIMIT', 'JOIN', 'ASC', 'DESC']
        messages = []
        scores = []
        missing = []
        extra = []

        for keyword in KEYWORDS:

            # Find missing keywords
            if keyword in self.grader_answer.upper():
                if keyword not in self.student_answer.upper():
                    scores.append(0)
                    missing.append(keyword)
                else:
                    scores.append(1)

            # Detect extra keywords
            if keyword in self.student_answer.upper():
                if keyword not in self.grader_answer.upper():
                    scores.append(0)
                    extra.append(keyword)
                else:
                    scores.append(1)

        # Calculate average
        score = numpy.average(scores)

        # Generate hints
        if missing:
            messages.append("Your query is missing keyword{}: {}.".format("s"[len(missing) == 1:],
                                                                        ", ".join(missing)))
        if extra:
            messages.append("Your query contains incorrect keyword{}: {}.".format("s"[len(extra) == 1:],
                                                                                ", ".join(extra)))
        return score, " ".join(messages)
